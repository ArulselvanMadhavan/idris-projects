* Interactive development with types
*** Type Driven Development
    1. Type - Either write a type to begin the process, or inspect the
       type of a hole to decide how to continue the process
    2. Define - Create the structure of a function definition either by
       creating an outline of a definition or breaking it down into
       smaller components
    3. Refine - Improve an exiting definition either by filling in a
       hole or making its type more precise.

*** Interactive development features
    - ~Add definitions~ - Add skeleton definition based on type definition.
    - ~Case analysis~ - Given a skeleton function defintion with
      arguments, Idris can use the types of those arguments to help
      define the function by pattern matching.
    - ~Expression search~ - Given a hole with a precise enough type,
      Idris can try to find an expression that satisfies the hole's
      type, refining the definition.

*** Totality checking
    - Idris considers a function as total, if
      - It has clauses that cover all possible well-typed inputs
      - All recursive calls converge on a base case
    - ~total~ annotation before function declaration indicates to
      idris that you intend to write a total function.

*** Mutually defined functions
    Idris processes input files from top to bottom and requires types and functions to be
    defined before use. This is necessary due to complications that arise with dependent
    types, where the definition of a function can affect a type.
    Itâ€™s nevertheless sometimes useful to define two or more functions in terms of each
    other. This can be achieved in a mutual block. For example, you could define isEven
    in terms of an isOdd function, and vice versa:
    #+BEGIN_SRC idris
    mutual
      isEven : Nat -> Bool
      isEven Z = True
      isEven (S k) = isOdd k

      isOdd : Nat -> Bool
      isOdd Z = False
      isOdd (S k) = isEven k
    #+END_SRC
